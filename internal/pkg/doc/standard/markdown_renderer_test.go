package standard

import (
	"regexp"
	"testing"

	standardAPI "github.com/orbiqd/orbiqd-projectkit/pkg/doc/standard"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func newMinimalStandard() standardAPI.Standard {
	return standardAPI.Standard{
		Metadata: standardAPI.Metadata{
			Id:      "test-standard",
			Name:    "Test Standard",
			Version: "1.0.0",
			Tags:    []string{"test-tag"},
			Scope: standardAPI.ScopeMetadata{
				Languages: []string{"en"},
			},
			Related: standardAPI.RelationMetadata{},
		},
		Specification: standardAPI.Specification{
			Purpose: "Test purpose for standard",
			Goals:   []string{"Test goal for standard"},
		},
		Requirements: standardAPI.Requirements{
			Rules: []standardAPI.RequirementRule{
				{
					Level:     "must",
					Statement: "Test statement for requirement",
					Rationale: "Test rationale for requirement",
				},
			},
		},
		Examples: standardAPI.Examples{
			Good: []standardAPI.Example{
				{
					Title:    "Test Example",
					Language: "go",
					Snippet:  "code snippet",
					Reason:   "Test reason for example",
				},
			},
		},
	}
}

func TestMarkdownRenderer_FileExtension_WhenCalled_ThenReturnsMdExtension(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()

	result := renderer.FileExtension()

	assert.Equal(t, ".md", result)
}

func TestMarkdownRenderer_Render_WhenMinimalStandard_ThenRendersTitle(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "# Test Standard")
}

func TestMarkdownRenderer_Render_WhenMinimalStandard_ThenRendersVersionTagsAndScope(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "**Version:** 1.0.0")
	assert.Contains(t, string(result), "**Tags:** test-tag")
	assert.Contains(t, string(result), "**Scope:**")
	assert.Contains(t, string(result), "- **Languages:** en")
}

func TestMarkdownRenderer_Render_WhenMinimalStandard_ThenRendersSpecification(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "## Specification")
	assert.Contains(t, string(result), "### Purpose")
	assert.Contains(t, string(result), "Test purpose for standard")
	assert.Contains(t, string(result), "### Goals")
	assert.Contains(t, string(result), "1. Test goal for standard")
}

func TestMarkdownRenderer_Render_WhenMinimalStandard_ThenRendersRequirements(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "## Requirements")
	assert.Contains(t, string(result), "### Rule 1: **MUST**")
	assert.Contains(t, string(result), "**Statement:** Test statement for requirement")
	assert.Contains(t, string(result), "**Rationale:** Test rationale for requirement")
}

func TestMarkdownRenderer_Render_WhenMinimalStandard_ThenRendersGoodExamples(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "## Good Examples")
	assert.Contains(t, string(result), "### Test Example")
	assert.Contains(t, string(result), "```go")
	assert.Contains(t, string(result), "code snippet")
	assert.Contains(t, string(result), "```")
	assert.Contains(t, string(result), "**Reason:** Test reason for example")
}

func TestMarkdownRenderer_Render_WhenMinimalStandard_ThenRendersTableOfContents(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "## Table of Contents")
	assert.Contains(t, string(result), "- [Specification](#specification)")
	assert.Contains(t, string(result), "- [Purpose](#purpose)")
	assert.Contains(t, string(result), "- [Goals](#goals)")
	assert.Contains(t, string(result), "- [Requirements](#requirements)")
	assert.Contains(t, string(result), "- [Good Examples](#good-examples)")
}

func TestMarkdownRenderer_Render_WhenMinimalStandard_ThenRendersFooter(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "---")
	assert.Regexp(t, regexp.MustCompile(`\*This document was automatically generated by projectkit on \d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2} \w+\. Do not edit manually\.\*`), string(result))
}

func TestMarkdownRenderer_Render_WhenHasNonGoals_ThenRendersNonGoalsSection(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()
	standard.Specification.NonGoals = []string{"This is not a goal", "Another non-goal"}

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "### Non-Goals")
	assert.Contains(t, string(result), "1. This is not a goal")
	assert.Contains(t, string(result), "2. Another non-goal")
	assert.Contains(t, string(result), "- [Non-Goals](#non-goals)")
}

func TestMarkdownRenderer_Render_WhenHasDefinitionsWithFields_ThenRendersFieldsTable(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()
	standard.Definitions = &standardAPI.Definitions{
		Fields: []standardAPI.FieldDefinition{
			{FieldName: "fieldOne"},
			{FieldName: "fieldTwo"},
		},
	}

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "## Definitions")
	assert.Contains(t, string(result), "### Fields")
	assert.Contains(t, string(result), "| Field Name |")
	assert.Contains(t, string(result), "|------------|")
	assert.Contains(t, string(result), "| fieldOne |")
	assert.Contains(t, string(result), "| fieldTwo |")
	assert.Contains(t, string(result), "- [Definitions](#definitions)")
	assert.Contains(t, string(result), "- [Fields](#fields)")
}

func TestMarkdownRenderer_Render_WhenHasDefinitionsWithTerms_ThenRendersTermsTable(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()
	standard.Definitions = &standardAPI.Definitions{
		Terms: []standardAPI.TermDefinition{
			{
				Abbreviation: "API",
				Term:         "Application Programming Interface",
				Meaning:      "A set of protocols for building software",
			},
			{
				Abbreviation: "CLI",
				Term:         "Command Line Interface",
				Meaning:      "A text-based user interface",
			},
		},
	}

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "## Definitions")
	assert.Contains(t, string(result), "### Terms")
	assert.Contains(t, string(result), "| Abbreviation | Term | Meaning |")
	assert.Contains(t, string(result), "|--------------|------|---------|")
	assert.Contains(t, string(result), "| API | Application Programming Interface | A set of protocols for building software |")
	assert.Contains(t, string(result), "| CLI | Command Line Interface | A text-based user interface |")
	assert.Contains(t, string(result), "- [Definitions](#definitions)")
	assert.Contains(t, string(result), "- [Terms](#terms)")
}

func TestMarkdownRenderer_Render_WhenHasGoldenPath_ThenRendersGoldenPathSection(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()
	standard.GoldenPath = &standardAPI.GoldenPath{
		Steps: []string{"First step in golden path", "Second step in golden path"},
	}

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "## Golden Path")
	assert.Contains(t, string(result), "### Steps")
	assert.Contains(t, string(result), "1. First step in golden path")
	assert.Contains(t, string(result), "2. Second step in golden path")
	assert.Contains(t, string(result), "- [Golden Path](#golden-path)")
	assert.Contains(t, string(result), "- [Steps](#steps)")
}

func TestMarkdownRenderer_Render_WhenHasGoldenPathWithExamples_ThenRendersGoldenPathExamples(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()
	standard.GoldenPath = &standardAPI.GoldenPath{
		Steps: []string{"First step in golden path"},
		Examples: []standardAPI.GoldenPathExample{
			{
				Name:  "Example One",
				When:  []string{"When condition A", "When condition B"},
				Steps: []string{"Step one", "Step two"},
				Examples: []standardAPI.GoldenPathExampleFile{
					{
						Path:    "path/to/file.go",
						Snippet: "code example\n\n",
					},
				},
			},
		},
	}

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "### Examples")
	assert.Contains(t, string(result), "#### Example One")
	assert.Contains(t, string(result), "**When:**")
	assert.Contains(t, string(result), "- When condition A")
	assert.Contains(t, string(result), "- When condition B")
	assert.Contains(t, string(result), "**Steps:**")
	assert.Contains(t, string(result), "1. Step one")
	assert.Contains(t, string(result), "2. Step two")
	assert.Contains(t, string(result), "**`path/to/file.go`**")
	assert.Contains(t, string(result), "```")
	assert.Contains(t, string(result), "code example")
	assert.Contains(t, string(result), "- [Examples](#examples)")
	assert.Contains(t, string(result), "- [Example One](#example-one)")
}

func TestMarkdownRenderer_Render_WhenHasBadExamples_ThenRendersBadExamplesSection(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()
	standard.Examples.Bad = []standardAPI.Example{
		{
			Title:    "Bad Example",
			Language: "go",
			Snippet:  "bad code snippet",
			Reason:   "This is why it is bad",
		},
	}

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "## Bad Examples")
	assert.Contains(t, string(result), "### Bad Example")
	assert.Contains(t, string(result), "```go")
	assert.Contains(t, string(result), "bad code snippet")
	assert.Contains(t, string(result), "**Reason:** This is why it is bad")
	assert.Contains(t, string(result), "- [Bad Examples](#bad-examples)")
}

func TestMarkdownRenderer_Render_WhenHasReferences_ThenRendersReferencesTable(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()
	standard.References = []standardAPI.Reference{
		{
			Title: "Reference One",
			Type:  "Documentation",
			URI:   "https://example.com/ref1",
		},
		{
			Title: "Reference Two",
			Type:  "Article",
			URI:   "https://example.com/ref2",
		},
	}

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "## References")
	assert.Contains(t, string(result), "| Title | Type | Link |")
	assert.Contains(t, string(result), "|-------|------|------|")
	assert.Contains(t, string(result), "| Reference One | Documentation | https://example.com/ref1 |")
	assert.Contains(t, string(result), "| Reference Two | Article | https://example.com/ref2 |")
	assert.Contains(t, string(result), "- [References](#references)")
}

func TestMarkdownRenderer_Render_WhenHasRelatedStandards_ThenRendersRelatedSection(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()
	standard.Metadata.Related.Standard = []string{"https://example.com/standard1", "https://example.com/standard2"}

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "**Related standards:**")
	assert.Contains(t, string(result), "- https://example.com/standard1")
	assert.Contains(t, string(result), "- https://example.com/standard2")
}

func TestMarkdownRenderer_Render_WhenHasScopeAppliesTo_ThenRendersAppliesTo(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()
	standard.Metadata.Scope.AppliesTo = []string{"backend", "frontend"}

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "- **Applies to:** backend, frontend")
}

func TestMarkdownRenderer_Render_WhenHasScopeNotApplicableTo_ThenRendersNotApplicableTo(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()
	standard.Metadata.Scope.NotApplicableTo = []string{"mobile", "embedded"}

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "- **Not applicable to:** mobile, embedded")
}

func TestMarkdownRenderer_Render_WhenNoOptionalSections_ThenOmitsThem(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.NotContains(t, string(result), "### Non-Goals")
	assert.NotContains(t, string(result), "## Definitions")
	assert.NotContains(t, string(result), "## Golden Path")
	assert.NotContains(t, string(result), "## Bad Examples")
	assert.NotContains(t, string(result), "## References")
	assert.NotContains(t, string(result), "**Related standards:**")
	assert.NotContains(t, string(result), "**Applies to:**")
	assert.NotContains(t, string(result), "**Not applicable to:**")
}

func TestMarkdownRenderer_Render_WhenMultipleRules_ThenRendersAllWithIncrementingNumbers(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()
	standard.Requirements.Rules = []standardAPI.RequirementRule{
		{
			Level:     "must",
			Statement: "First requirement statement",
			Rationale: "First rationale",
		},
		{
			Level:     "should",
			Statement: "Second requirement statement",
			Rationale: "Second rationale",
		},
		{
			Level:     "may",
			Statement: "Third requirement statement",
			Rationale: "Third rationale",
		},
	}

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "### Rule 1: **MUST**")
	assert.Contains(t, string(result), "**Statement:** First requirement statement")
	assert.Contains(t, string(result), "**Rationale:** First rationale")
	assert.Contains(t, string(result), "### Rule 2: **SHOULD**")
	assert.Contains(t, string(result), "**Statement:** Second requirement statement")
	assert.Contains(t, string(result), "**Rationale:** Second rationale")
	assert.Contains(t, string(result), "### Rule 3: **MAY**")
	assert.Contains(t, string(result), "**Statement:** Third requirement statement")
	assert.Contains(t, string(result), "**Rationale:** Third rationale")
}

func TestMarkdownRenderer_Render_WhenRuleHasExceptions_ThenRendersExceptions(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()
	standard.Requirements.Rules[0].Exceptions = []standardAPI.RequirementException{
		{When: "Exception one applies"},
		{When: "Exception two applies"},
	}

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "**Exceptions:**")
	assert.Contains(t, string(result), "- Exception one applies")
	assert.Contains(t, string(result), "- Exception two applies")
}

func TestMarkdownRenderer_Render_WhenRuleHasVerificationMethods_ThenRendersVerification(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()
	standard.Requirements.Rules[0].VerificationMethod = []standardAPI.RequirementVerificationMethod{
		{
			Type: "Manual review",
			Hint: "Check the code manually",
		},
		{
			Type: "Automated test",
			Hint: "Run the test suite",
		},
	}

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "**Verification:**")
	assert.Contains(t, string(result), "- **Manual review:** Check the code manually")
	assert.Contains(t, string(result), "- **Automated test:** Run the test suite")
}

func TestMarkdownRenderer_Render_WhenMultipleGoals_ThenRendersNumberedList(t *testing.T) {
	t.Parallel()

	renderer := NewMarkdownRenderer()
	standard := newMinimalStandard()
	standard.Specification.Goals = []string{
		"First goal of the standard",
		"Second goal of the standard",
		"Third goal of the standard",
	}

	result, err := renderer.Render(standard)

	require.NoError(t, err)
	assert.Contains(t, string(result), "1. First goal of the standard")
	assert.Contains(t, string(result), "2. Second goal of the standard")
	assert.Contains(t, string(result), "3. Third goal of the standard")
}

func TestSlugify(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "WhenHasSpaces_ThenReplacesWithDashes",
			input:    "Hello World Test",
			expected: "hello-world-test",
		},
		{
			name:     "WhenHasUppercase_ThenConvertsToLowercase",
			input:    "UPPERCASE",
			expected: "uppercase",
		},
		{
			name:     "WhenHasAsterisk_ThenRemovesIt",
			input:    "text*with*asterisks",
			expected: "textwithasterisks",
		},
		{
			name:     "WhenHasColon_ThenRemovesIt",
			input:    "text:with:colons",
			expected: "textwithcolons",
		},
		{
			name:     "WhenHasComma_ThenRemovesIt",
			input:    "text,with,commas",
			expected: "textwithcommas",
		},
		{
			name:     "WhenHasPeriod_ThenRemovesIt",
			input:    "text.with.periods",
			expected: "textwithperiods",
		},
		{
			name:     "WhenHasParentheses_ThenRemovesThem",
			input:    "text(with)parentheses",
			expected: "textwithparentheses",
		},
		{
			name:     "WhenHasSingleQuote_ThenRemovesIt",
			input:    "text'with'quotes",
			expected: "textwithquotes",
		},
		{
			name:     "WhenHasDoubleQuote_ThenRemovesIt",
			input:    "text\"with\"doublequotes",
			expected: "textwithdoublequotes",
		},
		{
			name:     "WhenHasMixedSpecialChars_ThenHandlesAll",
			input:    "Rule 1: *MUST* (Required)",
			expected: "rule-1-must-required",
		},
		{
			name:     "WhenEmpty_ThenReturnsEmpty",
			input:    "",
			expected: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			slugifyFunc := funcMap["slugify"].(func(string) string)

			result := slugifyFunc(tt.input)

			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestTrimTrailingNewlines(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "WhenHasTrailingNewlines_ThenRemovesThem",
			input:    "text with newlines\n\n\n",
			expected: "text with newlines",
		},
		{
			name:     "WhenHasNoTrailingNewlines_ThenReturnsUnchanged",
			input:    "text without newlines",
			expected: "text without newlines",
		},
		{
			name:     "WhenOnlyNewlines_ThenReturnsEmpty",
			input:    "\n\n\n",
			expected: "",
		},
		{
			name:     "WhenEmpty_ThenReturnsEmpty",
			input:    "",
			expected: "",
		},
		{
			name:     "WhenHasLeadingNewlines_ThenKeepsThem",
			input:    "\n\ntext\n\n",
			expected: "\n\ntext",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			trimFunc := funcMap["trimTrailingNewlines"].(func(string) string)

			result := trimFunc(tt.input)

			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestAdd(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name     string
		a        int
		b        int
		expected int
	}{
		{
			name:     "WhenPositiveNumbers_ThenAdds",
			a:        5,
			b:        3,
			expected: 8,
		},
		{
			name:     "WhenZero_ThenReturnsOther",
			a:        0,
			b:        5,
			expected: 5,
		},
		{
			name:     "WhenNegativeNumbers_ThenAdds",
			a:        -5,
			b:        -3,
			expected: -8,
		},
		{
			name:     "WhenMixedSigns_ThenAdds",
			a:        5,
			b:        -3,
			expected: 2,
		},
		{
			name:     "WhenBothZero_ThenReturnsZero",
			a:        0,
			b:        0,
			expected: 0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			addFunc := funcMap["add"].(func(int, int) int)

			result := addFunc(tt.a, tt.b)

			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestJoin(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name      string
		slice     []string
		separator string
		expected  string
	}{
		{
			name:      "WhenMultipleElements_ThenJoins",
			slice:     []string{"a", "b", "c"},
			separator: ", ",
			expected:  "a, b, c",
		},
		{
			name:      "WhenSingleElement_ThenReturnsElement",
			slice:     []string{"only"},
			separator: ", ",
			expected:  "only",
		},
		{
			name:      "WhenEmpty_ThenReturnsEmpty",
			slice:     []string{},
			separator: ", ",
			expected:  "",
		},
		{
			name:      "WhenDifferentSeparator_ThenUsesSeparator",
			slice:     []string{"a", "b", "c"},
			separator: " | ",
			expected:  "a | b | c",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			joinFunc := funcMap["join"].(func([]string, string) string)

			result := joinFunc(tt.slice, tt.separator)

			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestCodeFence_WhenCalled_ThenReturnsTripleBacktick(t *testing.T) {
	t.Parallel()

	codeFenceFunc := funcMap["codeFence"].(func() string)

	result := codeFenceFunc()

	assert.Equal(t, "```", result)
}
